<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据流中的第K大元素</title>
    <url>/2021/03/13/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F(0,i)/</url>
    <content><![CDATA[<h3 id="Given-any-permutation-of-the-numbers-0-1-2-…-N−1-it-is-easy-to-sort-them-in-increasing-order-But-what-if-Swap-0-is-the-ONLY-operation-that-is-allowed-to-use-For-example-to-sort-4-0-2-1-3-we-may-apply-the-swap-operations-in-the-following-way"><a href="#Given-any-permutation-of-the-numbers-0-1-2-…-N−1-it-is-easy-to-sort-them-in-increasing-order-But-what-if-Swap-0-is-the-ONLY-operation-that-is-allowed-to-use-For-example-to-sort-4-0-2-1-3-we-may-apply-the-swap-operations-in-the-following-way" class="headerlink" title="Given any permutation of the numbers {0, 1, 2,…, N−1}, it is easy to sort them in increasing order. But what if Swap(0, *) is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way:"></a>Given any permutation of the numbers {0, 1, 2,…, N−1}, it is easy to sort them in increasing order. But what if Swap(0, *) is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way:</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Swap</span>(<span class="number">0</span>, <span class="number">1</span>) =&gt; &#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="attribute">Swap</span>(<span class="number">0</span>, <span class="number">3</span>) =&gt; &#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>&#125;</span><br><span class="line"><span class="attribute">Swap</span>(<span class="number">0</span>, <span class="number">4</span>) =&gt; &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>
<p>Now you are asked to find the minimum number of swaps need to sort the given permutation of the first N nonnegative integers.</p>
<h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><p>Each input file contains one test case, which gives a positive N (≤10<sup>5</sup>) followed by a permutation sequence of {0, 1, …, N−1}. All the numbers in a line are separated by a space.</p>
<h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><p>For each case, simply print in a line the minimum number of swaps need to sort the given permutation.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">5</span> <span class="number">7</span> <span class="number">2</span> <span class="number">6</span> <span class="number">4</span> <span class="number">9</span> <span class="number">0</span> <span class="number">8</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p>本题的思路是找出数列中已经在排好位置上的数字的个数odd和数字循环体的个数fus，以及判断0是否在数字循环体中还是在排好的位置上<br>假设0在循环体上，该循环体除0外有n个元素，则排好这几个元素和0只需要n次交换。如果0不在该循环体上，则需要先把0换进循环体，然<br>后再循环交换，共需n+1次，而那些odd个已经排好位置的就不用交换。所以最后需要交换的次数是</p>
<ul>
<li>N - odd + fus 如果0不在循环体内</li>
<li>N - odd + fus - 2 如果0在循环体内</li>
</ul>
<p>最后附上c++代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newSwap</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">bool</span> zero = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> odd = <span class="number">0</span>,fus = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;nums[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                zero = <span class="literal">true</span>;</span><br><span class="line">            odd++;  <span class="comment">//排好位置的数字</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]!=i)&#123;</span><br><span class="line">            fus++;  <span class="comment">//形成数字环的个数</span></span><br><span class="line">            <span class="keyword">while</span>(nums[i]!=i)&#123;</span><br><span class="line">                swap(i,nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> nums;</span><br><span class="line">    <span class="keyword">if</span>(zero)&#123;</span><br><span class="line">        <span class="keyword">return</span> n-odd+fus;  <span class="comment">//数字0已经排好位置</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n-odd+fus<span class="number">-2</span>;  <span class="comment">//数字0在数字环中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;newSwap(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>数据流中的第K大元素</title>
    <url>/2021/02/11/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h3 id="设计一个找到数据流中第-k-大元素的类（class）。注意是排序后的第-k-大元素，不是第-k-个不同的元素。"><a href="#设计一个找到数据流中第-k-大元素的类（class）。注意是排序后的第-k-大元素，不是第-k-个不同的元素。" class="headerlink" title="设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。"></a>设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</h3><p>请实现 KthLargest 类：</p>
<ul>
<li><p>KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。</p>
</li>
<li><p>int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。</p>
<p>初始代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> KthLargest &#123;</span><br><span class="line">public:</span><br><span class="line">	<span class="constructor">KthLargest(<span class="params">int</span> <span class="params">k</span>, <span class="params">vector</span>&lt;<span class="params">int</span>&gt;&amp; <span class="params">nums</span>)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> add(<span class="built_in">int</span> <span class="keyword">val</span>) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="meta"><span class="meta-string">&quot;KthLargest&quot;</span>, <span class="meta-string">&quot;add&quot;</span>, <span class="meta-string">&quot;add&quot;</span>, <span class="meta-string">&quot;add&quot;</span>, <span class="meta-string">&quot;add&quot;</span>, <span class="meta-string">&quot;add&quot;</span></span>]</span><br><span class="line">[<span class="meta">[3, [4, 5, 8, 2</span>]], [<span class="number">3</span>], [<span class="number">5</span>], [<span class="number">10</span>], [<span class="number">9</span>], [<span class="number">4</span>]]</span><br><span class="line">输出：</span><br><span class="line">[<span class="meta">null, 4, 5, 5, 8, 8</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">KthLargest kthLargest = <span class="keyword">new</span> KthLargest(<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>]);</span><br><span class="line">kthLargest.<span class="keyword">add</span>(<span class="number">3</span>);   <span class="comment">// return 4</span></span><br><span class="line">kthLargest.<span class="keyword">add</span>(<span class="number">5</span>);   <span class="comment">// return 5</span></span><br><span class="line">kthLargest.<span class="keyword">add</span>(<span class="number">10</span>);  <span class="comment">// return 5</span></span><br><span class="line">kthLargest.<span class="keyword">add</span>(<span class="number">9</span>);   <span class="comment">// return 8</span></span><br><span class="line">kthLargest.<span class="keyword">add</span>(<span class="number">4</span>);   <span class="comment">// return 8</span></span><br></pre></td></tr></table></figure>
<p>提示：</p>
</li>
<li><p>1 &lt;= k &lt;= 104</p>
</li>
<li><p>0 &lt;= nums.length &lt;= 104</p>
</li>
<li><p>-104 &lt;= nums[i] &lt;= 104</p>
</li>
<li><p>-104 &lt;= val &lt;= 104</p>
</li>
<li><p>最多调用 add 方法 104 次</p>
</li>
<li><p>题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素</p>
</li>
</ul>
<p>题目来源：<br><font color="#0000dd"><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/">力扣703</a></font><br /></p>
<p>根据题目要求，我们很快就明白，add()的作用是将一个新的数加入向量后，返回新向量中第三大的数。联想一下学过的数据结构课，堆(heap)很适合找出最值，我们很容易想到用两种方式。</p>
<ol>
<li>用最大堆去做。思路就是初始化的时候建堆，然后在add()函数中，添加一个元素时保持堆的性质，然后取k次堆顶元素，第k个就是我们要返回的数值，再把这k个数放回堆中，然后进入下一次add()。经过实践证明，这种方法数据一大就超时，建议使用下面一种方法。</li>
<li>用最小堆去做。思路同样是初始化时建堆，但是不同的是，这次是最小堆，建完堆后如果堆中元素的个数大于k值，就移除最小值，直到堆中元素等于k值。这样堆顶元素就是我们需要的第k大的元素了，并且堆的元素个数保持为k，不会越来越大。在add()函数中,我们只要五步:插入元素-&gt;保持堆性质-&gt;删除堆顶元素-&gt;保持堆性质-&gt;返回堆顶元素。<br>代码如下:<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> KthLargest &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; vNum;  <span class="comment">//存放数据</span></span><br><span class="line">    <span class="built_in">int</span> k;  <span class="comment">//存放题目给的k值</span></span><br><span class="line"></span><br><span class="line">    <span class="constructor">KthLargest(<span class="params">int</span> <span class="params">k</span>, <span class="params">vector</span>&lt;<span class="params">int</span>&gt;&amp; <span class="params">nums</span>)</span> &#123;</span><br><span class="line">        make<span class="constructor">_heap(<span class="params">nums</span>.<span class="params">begin</span>()</span>, nums.<span class="keyword">end</span><span class="literal">()</span>, greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);  <span class="comment">//建立最小堆</span></span><br><span class="line">        <span class="keyword">while</span> (nums.size<span class="literal">()</span> &gt; k) &#123;  <span class="comment">//删除最小堆中比第k大元素还要小的元素</span></span><br><span class="line">            pop<span class="constructor">_heap(<span class="params">nums</span>.<span class="params">begin</span>()</span>, nums.<span class="keyword">end</span><span class="literal">()</span>,greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);  <span class="comment">//将堆顶元素移到尾部</span></span><br><span class="line">            nums.pop<span class="constructor">_back()</span>;  <span class="comment">//弹出尾部元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        vNum = nums;</span><br><span class="line">        this-&gt;k = k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> add(<span class="built_in">int</span> <span class="keyword">val</span>) &#123;</span><br><span class="line">        vNum.push<span class="constructor">_back(<span class="params">val</span>)</span>;  <span class="comment">//将给定数据插入尾部</span></span><br><span class="line">        push<span class="constructor">_heap(<span class="params">vNum</span>.<span class="params">begin</span>()</span>, vNum.<span class="keyword">end</span><span class="literal">()</span>, greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);  <span class="comment">//保持最小堆性质</span></span><br><span class="line">        <span class="keyword">if</span> (vNum.size<span class="literal">()</span> &gt; k) &#123;  <span class="comment">//如果插入1个数据后数据的数量超过k个，就删除最小的数据</span></span><br><span class="line">            pop<span class="constructor">_heap(<span class="params">vNum</span>.<span class="params">begin</span>()</span>, vNum.<span class="keyword">end</span><span class="literal">()</span>, greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);</span><br><span class="line">            vNum.pop<span class="constructor">_back()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return vNum.front<span class="literal">()</span>;  <span class="comment">//返回堆顶元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
注释写的应该挺清楚了，就这样吧。<br><img src="https://s3.ax1x.com/2021/01/29/yPvumq.jpg" alt="yPvumq.jpg"></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>my-first-blog</title>
    <url>/2021/01/28/my-first-blog/</url>
    <content><![CDATA[<p>我的第一个博客，人生中第一个博客，今天是个值得纪念的日子，弄了半天博客还是进不去，我差点去世，于是重新搞了一遍，终于成功了。</p>
]]></content>
  </entry>
  <entry>
    <title>资源分享</title>
    <url>/2021/01/28/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>ASA Project:<a href="https://pan.baidu.com/s/1RtueS3lfRVR2AprBPZpZxw">https://pan.baidu.com/s/1RtueS3lfRVR2AprBPZpZxw</a> 提取码:fy04</p>
<p><img src="https://wx4.sinaimg.cn/mw690/006BOFtUgy1gn3qi6295fj30qo0qowgq.jpg" alt="haoye"></p>
]]></content>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
</search>
