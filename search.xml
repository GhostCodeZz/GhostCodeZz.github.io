<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>my-first-blog</title>
    <url>/2021/01/28/my-first-blog/</url>
    <content><![CDATA[<p>我的第一个博客，人生中第一个博客，今天是个值得纪念的日子，弄了半天博客还是进不去，我差点去世，于是重新搞了一遍，终于成功了。</p>
]]></content>
  </entry>
  <entry>
    <title>数据流中的第K大元素</title>
    <url>/2021/02/11/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h3 id="设计一个找到数据流中第-k-大元素的类（class）。注意是排序后的第-k-大元素，不是第-k-个不同的元素。"><a href="#设计一个找到数据流中第-k-大元素的类（class）。注意是排序后的第-k-大元素，不是第-k-个不同的元素。" class="headerlink" title="设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。"></a>设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</h3><p>请实现 KthLargest 类：</p>
<ul>
<li><p>KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。</p>
</li>
<li><p>int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。</p>
<p>初始代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> KthLargest &#123;</span><br><span class="line">public:</span><br><span class="line">	<span class="constructor">KthLargest(<span class="params">int</span> <span class="params">k</span>, <span class="params">vector</span>&lt;<span class="params">int</span>&gt;&amp; <span class="params">nums</span>)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> add(<span class="built_in">int</span> <span class="keyword">val</span>) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="meta"><span class="meta-string">&quot;KthLargest&quot;</span>, <span class="meta-string">&quot;add&quot;</span>, <span class="meta-string">&quot;add&quot;</span>, <span class="meta-string">&quot;add&quot;</span>, <span class="meta-string">&quot;add&quot;</span>, <span class="meta-string">&quot;add&quot;</span></span>]</span><br><span class="line">[<span class="meta">[3, [4, 5, 8, 2</span>]], [<span class="number">3</span>], [<span class="number">5</span>], [<span class="number">10</span>], [<span class="number">9</span>], [<span class="number">4</span>]]</span><br><span class="line">输出：</span><br><span class="line">[<span class="meta">null, 4, 5, 5, 8, 8</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">KthLargest kthLargest = <span class="keyword">new</span> KthLargest(<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>]);</span><br><span class="line">kthLargest.<span class="keyword">add</span>(<span class="number">3</span>);   <span class="comment">// return 4</span></span><br><span class="line">kthLargest.<span class="keyword">add</span>(<span class="number">5</span>);   <span class="comment">// return 5</span></span><br><span class="line">kthLargest.<span class="keyword">add</span>(<span class="number">10</span>);  <span class="comment">// return 5</span></span><br><span class="line">kthLargest.<span class="keyword">add</span>(<span class="number">9</span>);   <span class="comment">// return 8</span></span><br><span class="line">kthLargest.<span class="keyword">add</span>(<span class="number">4</span>);   <span class="comment">// return 8</span></span><br></pre></td></tr></table></figure>
<p>提示：</p>
</li>
<li><p>1 &lt;= k &lt;= 104</p>
</li>
<li><p>0 &lt;= nums.length &lt;= 104</p>
</li>
<li><p>-104 &lt;= nums[i] &lt;= 104</p>
</li>
<li><p>-104 &lt;= val &lt;= 104</p>
</li>
<li><p>最多调用 add 方法 104 次</p>
</li>
<li><p>题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素</p>
</li>
</ul>
<p>题目来源：<br><font color="#0000dd"><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/">力扣703</a></font><br /></p>
<p>根据题目要求，我们很快就明白，add()的作用是将一个新的数加入向量后，返回新向量中第三大的数。联想一下学过的数据结构课，堆(heap)很适合找出最值，我们很容易想到用两种方式。</p>
<ol>
<li>用最大堆去做。思路就是初始化的时候建堆，然后在add()函数中，添加一个元素时保持堆的性质，然后取k次堆顶元素，第k个就是我们要返回的数值，再把这k个数放回堆中，然后进入下一次add()。经过实践证明，这种方法数据一大就超时，建议使用下面一种方法。</li>
<li>用最小堆去做。思路同样是初始化时建堆，但是不同的是，这次是最小堆，建完堆后如果堆中元素的个数大于k值，就移除最小值，直到堆中元素等于k值。这样堆顶元素就是我们需要的第k大的元素了，并且堆的元素个数保持为k，不会越来越大。在add()函数中,我们只要五步:插入元素-&gt;保持堆性质-&gt;删除堆顶元素-&gt;保持堆性质-&gt;返回堆顶元素。<br>代码如下:<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> KthLargest &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; vNum;  <span class="comment">//存放数据</span></span><br><span class="line">    <span class="built_in">int</span> k;  <span class="comment">//存放题目给的k值</span></span><br><span class="line"></span><br><span class="line">    <span class="constructor">KthLargest(<span class="params">int</span> <span class="params">k</span>, <span class="params">vector</span>&lt;<span class="params">int</span>&gt;&amp; <span class="params">nums</span>)</span> &#123;</span><br><span class="line">        make<span class="constructor">_heap(<span class="params">nums</span>.<span class="params">begin</span>()</span>, nums.<span class="keyword">end</span><span class="literal">()</span>, greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);  <span class="comment">//建立最小堆</span></span><br><span class="line">        <span class="keyword">while</span> (nums.size<span class="literal">()</span> &gt; k) &#123;  <span class="comment">//删除最小堆中比第k大元素还要小的元素</span></span><br><span class="line">            pop<span class="constructor">_heap(<span class="params">nums</span>.<span class="params">begin</span>()</span>, nums.<span class="keyword">end</span><span class="literal">()</span>,greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);  <span class="comment">//将堆顶元素移到尾部</span></span><br><span class="line">            nums.pop<span class="constructor">_back()</span>;  <span class="comment">//弹出尾部元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        vNum = nums;</span><br><span class="line">        this-&gt;k = k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> add(<span class="built_in">int</span> <span class="keyword">val</span>) &#123;</span><br><span class="line">        vNum.push<span class="constructor">_back(<span class="params">val</span>)</span>;  <span class="comment">//将给定数据插入尾部</span></span><br><span class="line">        push<span class="constructor">_heap(<span class="params">vNum</span>.<span class="params">begin</span>()</span>, vNum.<span class="keyword">end</span><span class="literal">()</span>, greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);  <span class="comment">//保持最小堆性质</span></span><br><span class="line">        <span class="keyword">if</span> (vNum.size<span class="literal">()</span> &gt; k) &#123;  <span class="comment">//如果插入1个数据后数据的数量超过k个，就删除最小的数据</span></span><br><span class="line">            pop<span class="constructor">_heap(<span class="params">vNum</span>.<span class="params">begin</span>()</span>, vNum.<span class="keyword">end</span><span class="literal">()</span>, greater&lt;<span class="built_in">int</span>&gt;<span class="literal">()</span>);</span><br><span class="line">            vNum.pop<span class="constructor">_back()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return vNum.front<span class="literal">()</span>;  <span class="comment">//返回堆顶元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
注释写的应该挺清楚了，就这样吧。<br><img src="https://s3.ax1x.com/2021/01/29/yPvumq.jpg" alt="yPvumq.jpg"></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>资源分享</title>
    <url>/2021/01/28/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>ASA Project:<a href="https://pan.baidu.com/s/1RtueS3lfRVR2AprBPZpZxw">https://pan.baidu.com/s/1RtueS3lfRVR2AprBPZpZxw</a> 提取码:fy04</p>
<p><img src="https://wx4.sinaimg.cn/mw690/006BOFtUgy1gn3qi6295fj30qo0qowgq.jpg" alt="haoye"></p>
]]></content>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
</search>
